#!/bin/bash

# ==============================================================================
# Helper Functions
# ==============================================================================

# Check if a command exists
# Usage: command_exists "command_name"
command_exists() {
  command -v "$1" &> /dev/null
}

# Function to check for Next.js project indicators
# Returns 0 if Next.js indicators are found, 1 otherwise.
is_nextjs() {
  # Check for specific config files or directories commonly used by Next.js
  if [ -f "next.config.js" ] || [ -f "next.config.mjs" ] || [ -d ".next" ]; then
    return 0 # It's likely a Next.js project
  else
    return 1 # It's likely not
  fi
}

# Function to check for Vite project indicators
# Returns 0 if Vite indicators are found, 1 otherwise.
is_vite() {
  # Check for specific config files or the default build directory used by Vite
  if [ -f "vite.config.js" ] || [ -f "vite.config.ts" ] || [ -d "dist" ]; then
    return 0 # It's likely a Vite project
  else
    return 1 # It's likely not
  fi
}

# Function to remove directories and files safely with feedback.
# Usage: remove_with_feedback "path/to/target"
# Returns 0 on success (or if target doesn't exist), 1 on failure.
remove_with_feedback() {
  local target="$1"
  # Check if the file or directory exists
  if [ -e "$target" ]; then
    echo "üßπ Removing ${target}..."
    # Use rm -rf to remove recursively and forcefully
    rm -rf "$target"
    # Check the exit status of the rm command
    if [ $? -eq 0 ]; then
      echo "‚úÖ Successfully removed ${target}."
      return 0 # Indicate success
    else
      echo "‚ùå Failed to remove ${target}."
      return 1 # Indicate failure
    fi
  else
    # If the target doesn't exist, consider it a success (nothing to do)
    echo "‚ÑπÔ∏è  ${target} not found, skipping."
    return 0 # Indicate success
  fi
}

# Function to determine the OS-specific command to open a URL in the default browser.
# Prints the command (e.g., "xdg-open", "open", "start") or nothing if OS is unsupported.
get_open_cmd() {
  case "$(uname -s)" in
    Linux*)  echo "xdg-open" ;; # Standard Linux command
    Darwin*) echo "open" ;;     # macOS command
    CYGWIN*|MINGW*|MSYS*) echo "start" ;; # Windows (Git Bash, Cygwin, MinGW, MSYS)
    *)       echo "" ;;         # Unknown or unsupported OS
  esac
}

# ==============================================================================
# Core Alias Functions (rmall, re, rebuild)
# ==============================================================================

# --- rmall ---
# Removes node_modules and project-specific build artifacts (e.g., .next, dist).
# Returns 0 on success, 1 if any removal step failed.
rmall {
  echo "üöÄ Running rmall..."
  local success=true # Assume success initially

  # Remove node_modules first
  remove_with_feedback "node_modules" || success=false

  # Check for project type and remove corresponding build artifacts
  if is_nextjs; then
    echo "‚öõÔ∏è  Detected Next.js project."
    remove_with_feedback ".next" || success=false
  elif is_vite; then
    echo "‚ö° Detected Vite project."
    # Add other common Vite output dirs here if needed (e.g., build)
    remove_with_feedback "dist" || success=false
  else
    # If neither is detected based on common files/dirs
    echo "ü§î Neither Next.js nor Vite project detected (based on common configs/dirs)."
    echo "‚ÑπÔ∏è  Only removing node_modules."
  fi

  # Report final status
  if $success; then
    echo "‚úÖ rmall completed successfully!"
    return 0
  else
    echo "‚ùå rmall completed with errors."
    return 1
  fi
}

# --- re ---
# Reinstalls dependencies after cleaning using pnpm.
# Requires pnpm to be installed and package.json to exist.
# Returns 0 on success, 1 on failure.
re() {
  echo "üîÑ Running re (rmall + pnpm install)..."

  # Step 1: Run rmall
  if ! rmall; then
    echo "‚ùå Aborting re due to errors in rmall step."
    return 1
  fi

  # Step 2: Check prerequisites for installation
  if ! command_exists pnpm; then
    echo "‚ùå Error: 'pnpm' command not found."
    echo "   Please install pnpm: https://pnpm.io/installation"
    return 1
  fi
  if [ ! -f "package.json" ]; then
    echo "‚ùå Error: 'package.json' not found in the current directory."
    echo "   Cannot run 'pnpm install' without it."
    return 1
  fi

  # Step 3: Run pnpm install
  echo "üì¶ Installing dependencies with pnpm..."
  pnpm install
  if [ $? -eq 0 ]; then
    echo "‚úÖ Dependencies installed successfully!"
    return 0
  else
    echo "‚ùå Failed to install dependencies with pnpm."
    return 1
  fi
}

# --- rebuild ---
# Cleans (rmall), reinstalls (re), runs the dev server (pnpm run dev/start),
# and attempts to open the project URL in the browser.
# Requires pnpm, jq, stdbuf, and a 'dev' or 'start' script in package.json.
# Returns 0 if the process starts successfully, 1 otherwise.
rebuild() {
  echo "üõ†Ô∏è  Running rebuild (re + run dev server + open browser)..."

  # Step 1: Run re (which includes rmall and pnpm install)
  if ! re; then
    echo "‚ùå Aborting rebuild due to errors in re step."
    return 1
  fi

  # Step 2: Check prerequisites for running the dev server
  if ! command_exists jq; then
    echo "‚ùå Error: 'jq' command not found. jq is required to read the package.json scripts."
    echo "   Please install jq (e.g., 'sudo apt install jq', 'brew install jq', 'choco install jq')."
    return 1
  fi
   # Check for stdbuf (important for real-time output processing)
  if ! command_exists stdbuf; then
    echo "‚ùå Error: 'stdbuf' command not found. This is needed for real-time output processing."
    echo "   It's usually part of 'coreutils'. Try reinstalling/updating coreutils."
    return 1
  fi
  # Double-check package.json exists (should be guaranteed by 're' success)
  if [ ! -f "package.json" ]; then
    echo "‚ùå Error: 'package.json' not found." # Should not happen if 're' succeeded
    return 1
  fi

  # Determine the command to open the browser
  local open_cmd
  open_cmd=$(get_open_cmd)
  if [ -z "$open_cmd" ]; then
    echo "‚ö†Ô∏è Warning: Your operating system is not supported for automatically opening the browser."
    echo "   The server will still attempt to start, but you'll need to open the URL manually."
    # Allow script to continue, just won't open browser automatically
  fi

  # Step 3: Find the appropriate dev script ('dev' preferred, fallback to 'start')
  echo "üîç Checking package.json for dev script ('dev' or 'start')..."
  local script_name=""
  # Check if scripts.dev exists and is not null/empty using jq
  if jq -e '.scripts.dev | strings | length > 0' package.json > /dev/null; then
    script_name="dev"
    echo "‚úÖ Found 'dev' script in package.json."
  # If 'dev' not found, check for 'start'
  elif jq -e '.scripts.start | strings | length > 0' package.json > /dev/null; then
    script_name="start"
    echo "‚úÖ Found 'start' script in package.json."
  else
    echo "‚ùå Error: Could not find a runnable 'dev' or 'start' script defined in your package.json."
    return 1
  fi

  # Step 4: Run the dev server and attempt to open the browser
  echo "üöÄ Starting development server via 'pnpm run $script_name'..."
  echo "‚è≥ Watching output for server URL (e.g., http://localhost:3000)..."
  echo "   (Press Ctrl+C here to stop the server at any time)"

  local url_found=false
  local line
  local url

  # Execute pnpm run script.
  # Use stdbuf to force line-buffering on stdout/stderr, which helps grep/read process output faster.
  # Redirect stderr to stdout (2>&1) so the 'while read' loop captures both.
  stdbuf -oL -eL pnpm run "$script_name" 2>&1 | while IFS= read -r line; do
    # DEBUG: Print every line received
    # echo "[DEBUG] Line received: $line"

    # Print the line from the server output to the terminal
    echo "$line"

    # Check if we have already found the URL and if the open command is available
    if ! $url_found && [ -n "$open_cmd" ]; then
      # DEBUG: Indicate that we are checking this line for a URL
      # echo "[DEBUG] Checking line for URL..."

      # Try to extract the first http(s)://(localhost|127.0.0.1|0.0.0.0):port URL from the line
      # Added 0.0.0.0 to the pattern.
      url=$(echo "$line" | grep -oE '(http://|https://)(localhost|127\.0\.0\.1|0\.0\.0\.0):[0-9]+' | head -n 1)

      # If a URL was successfully extracted
      if [ -n "$url" ]; then
        # DEBUG: Indicate URL found
        # echo "[DEBUG] URL Found: $url"
        echo # Add a newline for cleaner output
        echo "‚úÖ URL Detected: $url"
        echo "üåç Attempting to open in browser using '$open_cmd'..."

        # Execute the open command.
        # NOTE: Removed '&>/dev/null &' for debugging. If this command prints errors, they will now be visible.
        # If it works, you can add '&>/dev/null &' back to run it silently in the background.
        "$open_cmd" "$url"
        open_exit_code=$? # Capture exit code of the open command

        if [ $open_exit_code -eq 0 ]; then
            echo "‚úÖ Browser command executed successfully."
        else
            echo "‚ùå Browser command '$open_cmd $url' failed with exit code $open_exit_code."
            echo "   You may need to open the URL manually."
        fi

        url_found=true # Set the flag to true so we don't try to open it again
        echo # Add another newline

        # DEBUG: Indicate that URL processing is done for this line
        # echo "[DEBUG] URL processing finished for this line."
      # else
        # DEBUG: Indicate URL not found in this line
        # echo "[DEBUG] No URL pattern matched in this line."
      fi
    fi
  done

  # --- Post-execution ---
  # The 'while read' loop finishes when the 'pnpm run' command terminates (e.g., user presses Ctrl+C).

  # Provide feedback based on whether the URL was ever found during execution
  if ! $url_found && [ -n "$open_cmd" ]; then
     echo "‚ö†Ô∏è  Warning: Server process finished or was stopped before a suitable localhost URL was detected in the output."
     echo "   Browser was not automatically opened."
  elif [ -z "$open_cmd" ]; then
      echo "‚ÑπÔ∏è  Server process finished or was stopped. Browser opening was skipped (unsupported OS or command failed)."
  else
      echo "‚ÑπÔ∏è  Server process finished or was stopped."
  fi

  # Return 0 indicating the rebuild command itself executed (though the server might have failed)
  return 0
}


# ==============================================================================
# Alias Setup Logic (Run when script is sourced)
# ==============================================================================

# Function to define the aliases in the current shell session.
setup_aliases() {
  local shell_rc_file=""
  local shell_name=""

  # Detect the current shell (Bash or Zsh)
  if [ -n "$BASH_VERSION" ]; then
    shell_name="Bash"
    shell_rc_file="$HOME/.bashrc" # Default Bash configuration file
  elif [ -n "$ZSH_VERSION" ]; then
    shell_name="Zsh"
    # Respect ZDOTDIR if set by the user, otherwise default to ~/.zshrc
    shell_rc_file="${ZDOTDIR:-$HOME}/.zshrc"
  else
    # If neither Bash nor Zsh, print an error and exit setup
    echo "‚ùå Shell not supported for automatic alias setup. This script requires Bash or Zsh."
    echo "‚ÑπÔ∏è  You can manually define the aliases 'rmall', 're', and 'rebuild' by adding the functions"
    echo "   above to your shell's configuration file (e.g., ~/.bash_profile, ~/.profile)."
    return 1 # Indicate failure
  fi

  echo "üêö Detected Shell: $shell_name"
  echo "‚öôÔ∏è  Configuring aliases: rmall, re, rebuild for the current session."

  # Define the aliases. This makes 'rmall' execute the 'rmall' function, etc.
  alias rmall="rmall"
  alias re="re"
  alias rebuild="rebuild"

  echo "‚úÖ Aliases 'rmall', 're', 'rebuild' are now active for this terminal session."
  echo # Add a blank line for readability

  # Provide instructions for making aliases permanent
  echo "üí° To make these aliases permanent:"
  echo "   1. Ensure this script file is saved somewhere permanent (e.g., ~/.local/bin/dev_aliases.sh)."
  echo "   2. Add the following line to your shell configuration file ('$shell_rc_file'):"
  echo "      source /path/to/your/script.sh"
  echo "      (Replace '/path/to/your/script.sh' with the actual path to this file)"
  echo "   3. Restart your terminal or run 'source $shell_rc_file'."
}

# Execute the alias setup function automatically when the script is sourced.
# The check prevents the setup from running if the script is executed directly (not sourced).
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # Script is being executed directly, not sourced. Maybe show help?
  echo "‚ÑπÔ∏è  This script is intended to be sourced to set up aliases."
  echo "   Example: source $0"
  echo "   Alternatively, add 'source /path/to/$0' to your ~/.bashrc or ~/.zshrc file."
else
  # Script is being sourced, run the setup.
  setup_aliases
fi
